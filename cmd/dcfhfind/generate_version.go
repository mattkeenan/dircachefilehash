//go:build ignore

package main

import (
	"fmt"
	"os"
	"os/exec"
	"strings"
)

func main() {
	version, commit, err := getVersionInfo()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error getting version info: %v\n", err)
		os.Exit(1)
	}

	// Generate constants_version.go file
	content := fmt.Sprintf(`// Code generated by go generate; DO NOT EDIT.

package main

// getVersionString returns the version string
func getVersionString() string {
	return "%s"
}

// getGitCommit returns the git commit hash
func getGitCommit() string {
	return "%s"
}
`, version, commit)

	err = os.WriteFile("constants_version.go", []byte(content), 0644)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error writing constants_version.go: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Generated constants_version.go: %s (commit %s)\n", version, commit)
}

func getVersionInfo() (version, commit string, err error) {
	// Get current commit hash
	commitCmd := exec.Command("git", "rev-parse", "HEAD")
	commitOutput, err := commitCmd.Output()
	if err != nil {
		return "v0.0.0", "unknown", nil // Fallback if not in git repo
	}
	commit = strings.TrimSpace(string(commitOutput))
	shortCommit := commit
	if len(commit) > 8 {
		shortCommit = commit[:8]
	}

	// Check if git repo is dirty (has uncommitted changes)
	isDirty := isGitDirty()

	// Get the latest tag
	tagCmd := exec.Command("git", "describe", "--tags", "--exact-match", "HEAD")
	tagOutput, err := tagCmd.Output()
	if err == nil {
		// We're exactly on a tag
		baseVersion := strings.TrimSpace(string(tagOutput))
		if isDirty {
			// Uncommitted changes on a tag: v1.2.3-UNCOMMITTED-abcd1234
			version = fmt.Sprintf("%s-UNCOMMITTED-%s", baseVersion, shortCommit)
		} else {
			// Clean tag: v1.2.3
			version = baseVersion
		}
		return version, commit, nil
	}

	// Not on a tag, get the latest tag and add commit info
	latestTagCmd := exec.Command("git", "describe", "--tags", "--abbrev=0")
	latestTagOutput, err := latestTagCmd.Output()
	if err != nil {
		// No tags found
		if isDirty {
			// No tags + uncommitted: v0.0.0-UNCOMMITTED-abcd1234
			version = fmt.Sprintf("v0.0.0-UNCOMMITTED-%s", shortCommit)
		} else {
			// No tags + clean: v0.0.0-abcd1234
			version = fmt.Sprintf("v0.0.0-%s", shortCommit)
		}
		return version, commit, nil
	}

	latestTag := strings.TrimSpace(string(latestTagOutput))
	if isDirty {
		// Post-tag with uncommitted changes: v1.2.3-UNCOMMITTED-abcd1234
		version = fmt.Sprintf("%s-UNCOMMITTED-%s", latestTag, shortCommit)
	} else {
		// Post-tag clean (goreleaser snapshot): v1.2.3-SNAPSHOT-abcd1234
		version = fmt.Sprintf("%s-SNAPSHOT-%s", latestTag, shortCommit)
	}
	return version, commit, nil
}

// isGitDirty checks if the git repository has uncommitted changes
func isGitDirty() bool {
	// Check for staged and unstaged changes
	statusCmd := exec.Command("git", "status", "--porcelain")
	statusOutput, err := statusCmd.Output()
	if err != nil {
		// If we can't check git status, assume clean
		return false
	}
	
	// If there's any output from git status --porcelain, the repo is dirty
	return len(strings.TrimSpace(string(statusOutput))) > 0
}